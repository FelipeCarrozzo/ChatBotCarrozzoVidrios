[
    {
        "id": "6d76aee88f994823",
        "type": "tab",
        "label": "Flujo 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "subflow_normalizar",
        "type": "subflow",
        "name": "SF - Normalizar Texto",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 80,
                "wires": [
                    {
                        "id": "sf_norm_fn"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 340,
                "y": 80,
                "wires": [
                    {
                        "id": "sf_norm_fn",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "8df5c20dddca9d11",
        "type": "telegram bot",
        "botname": "CarrozzoVidriosBot",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "pollinterval": 300,
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbothost": "0.0.0.0",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "093945d6cbd08c1b",
        "type": "global-config",
        "env": [
            {
                "name": "TELEGRAM_TOKEN",
                "value": "8557107744:AAGHP-WZ03RUbx2aGuc11z_CAefbXIcCves",
                "type": "str"
            }
        ],
        "modules": {}
    },
    {
        "id": "sf_norm_fn",
        "type": "function",
        "z": "subflow_normalizar",
        "name": "normalizar",
        "func": "let s = (msg.text_original ?? '').toString();\nmsg.payload = s.toUpperCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "99e7d99b9badbf41",
        "type": "debug",
        "z": "6d76aee88f994823",
        "name": "entradas usuario",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 500,
        "wires": []
    },
    {
        "id": "3f1899752c19b369",
        "type": "telegram receiver",
        "z": "6d76aee88f994823",
        "name": "",
        "bot": "8df5c20dddca9d11",
        "saveDataDir": "",
        "filterCommands": false,
        "x": 130,
        "y": 580,
        "wires": [
            [
                "99e7d99b9badbf41",
                "9ce3d5bb0df5ab47"
            ],
            []
        ]
    },
    {
        "id": "465d09dcd6d5f35c",
        "type": "inject",
        "z": "6d76aee88f994823",
        "name": "cargar catalogo",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 200,
        "y": 200,
        "wires": [
            [
                "945c4abf6133db9f"
            ]
        ]
    },
    {
        "id": "945c4abf6133db9f",
        "type": "file in",
        "z": "6d76aee88f994823",
        "name": "ruta a datos",
        "filename": "C:/Users/usr/.node-red/projects/ChatBotCarrozzoVidrios/data/output/pilkington.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 410,
        "y": 200,
        "wires": [
            [
                "fa3fac8d3fb23bda"
            ]
        ]
    },
    {
        "id": "fa3fac8d3fb23bda",
        "type": "json",
        "z": "6d76aee88f994823",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 590,
        "y": 200,
        "wires": [
            [
                "731867f6d2d279b8"
            ]
        ]
    },
    {
        "id": "731867f6d2d279b8",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "catalogo Pilkington",
        "func": "//msg.payload sea un array de objetos del cat√°logo\nconst catalog = msg.payload;\n\n//guardo el cat√°logo completo en la variable global\nglobal.set(\"catalogo.productos\", catalog);\n\n//mostrar cu√°ntos productos se cargaron\nnode.status({fill:\"green\", shape:\"dot\", text:`${catalog.length} productos cargados`});\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 200,
        "wires": [
            [
                "b6be091188b8e890",
                "1ed20e756ff9133c"
            ]
        ]
    },
    {
        "id": "b6be091188b8e890",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "extraer marcas y modelos",
        "func": "try {\n\n  //verificar que el cat√°logo exista\n  const catalog = global.get(\"catalogo.productos\");\n\n  if (!catalog) {\n    node.error(\"El cat√°logo global 'catalogo.productos' no existe\", msg);\n    msg.payload = { error: true, detail: \"No se encontr√≥ el cat√°logo cargado.\" };\n    return msg;\n  }\n\n  if (!Array.isArray(catalog)) {\n    node.error(\"El cat√°logo no es un array\", msg);\n    msg.payload = { error: true, detail: \"El cat√°logo tiene un formato inv√°lido.\" };\n    return msg;\n  }\n\n  if (catalog.length === 0) {\n    node.error(\"El cat√°logo est√° vac√≠o\", msg);\n    msg.payload = { error: true, detail: \"El cat√°logo no contiene productos.\" };\n    return msg;\n  }\n\n\n  //normalizador defensivo\n  const normalize = s => (s ?? \"\")\n    .toString()\n    .toUpperCase()\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\")\n    .replace(/\\s+/g, \" \")\n    .trim();\n\n\n  //extraer marcas deduplicadas (con validaci√≥n)\n  const marcas = [...new Set(\n    catalog.map(item => {\n      if (!item?.marca) {\n        node.error(`Producto sin marca detectado: ${JSON.stringify(item)}`, msg);\n        return null;\n      }\n      return normalize(item.marca);\n    })\n  )].filter(Boolean);\n\n\n  //construir modelos por marca\n  const modelos = {};\n\n  for (const item of catalog) {\n    const marca = normalize(item.marca);\n    const modelo = normalize(item.modelo);\n\n    if (!marca || !modelo) {\n      node.error(`Entrada inv√°lida detectada: marca=\"${item.marca}\", modelo=\"${item.modelo}\"`, msg);\n      continue;\n    }\n\n    if (!modelos[marca]) modelos[marca] = new Set();\n    modelos[marca].add(modelo);\n  }\n\n  //convertir sets en arrays\n  for (const marca in modelos) {\n    modelos[marca] = Array.from(modelos[marca]);\n  }\n\n\n  //guardar en variables globales\n  global.set(\"catalogo.marcas\", marcas);\n  global.set(\"catalogo.modelos\", modelos);\n\n  node.status({ fill: \"green\", shape: \"dot\", text: `${marcas.length} marcas cargadas` });\n  // msg.payload = modelos;\n  msg.payload = global.get(\"catalogo.marcas\");\n\n  return msg;\n\n\n} catch (err) {\n\n  //error inesperado\n  node.error(`Error inesperado en extracci√≥n de marcas/modelos: ${err.message}`, msg);\n\n  msg.payload = {\n    error: true,\n    detail: \"Ocurri√≥ un error inesperado procesando el cat√°logo.\",\n    systemMessage: err.message\n  };\n\n  return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 240,
        "wires": [
            [
                "0c5521db7efc2f6e"
            ]
        ]
    },
    {
        "id": "0c5521db7efc2f6e",
        "type": "debug",
        "z": "6d76aee88f994823",
        "name": "salida marcas y modelos",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1350,
        "y": 240,
        "wires": []
    },
    {
        "id": "c8423aeb93ef2a9a",
        "type": "telegram sender",
        "z": "6d76aee88f994823",
        "name": "",
        "bot": "8df5c20dddca9d11",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1550,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "d16fdcf0d9f4353c",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "pedir modelo",
        "func": "try {\n\n    //validaci√≥n del payload\n    if (!msg.payload) {\n        node.error(\"pedir modelo: msg.payload est√° indefinido\", msg);\n        return null;\n    }\n\n    const chatId = msg.chatId;\n\n    if (!chatId) {\n        node.error(\"pedir modelo: falta msg.chatId\", msg);\n        return null;\n    }\n\n    //texto ingresado por el usuario\n    const text = (msg.payload || \"\").toString().trim().toLowerCase();\n\n    //recuperar estado del usuario\n    let estado = flow.get(`estado_${chatId}`);\n    if (!estado || !estado.paso) {\n        node.error(`pedir modelo: estado inexistente o inv√°lido para chatId=${chatId}`, msg);\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: \"‚ö†Ô∏è Ocurri√≥ un problema con tu sesi√≥n. Escrib√≠ /start para reiniciar.\"\n        };\n        return msg;\n    }\n\n\n    //solo si el paso es marca\n    if (estado.paso === \"marca\") {\n\n        //obtener marcas y modelos del cat√°logo\n        const marcas = global.get(\"catalogo.marcas\");\n        const modelosPorMarca = global.get(\"catalogo.modelos\");\n\n        //validaciones de las globales\n        if (!marcas || !Array.isArray(marcas)) {\n            node.error(\"pedir modelo: global.marcas_unicas no existe o no es array\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå Error interno al cargar las marcas. Prob√° m√°s tarde.\"\n            };\n            return msg;\n        }\n\n        if (!modelosPorMarca || typeof modelosPorMarca !== \"object\") {\n            node.error(\"pedir modelo: global.modelos_por_marca est√° ausente o mal formado\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå Error interno al cargar los modelos. Prob√° m√°s tarde.\"\n            };\n            return msg;\n        }\n\n        //buscar la marca ingresada\n        const marcaElegida = marcas.find(m =>\n            m.toLowerCase() === text ||\n            m.toLowerCase().startsWith(text)\n        );\n\n        if (!marcaElegida) {\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå No reconozco esa marca. Escrib√≠ /start para volver a empezar.\"\n            };\n            return msg;\n        }\n\n        //marcar nuevo estado\n        estado.marca = marcaElegida;\n        estado.paso = \"modelo\";\n        flow.set(`estado_${chatId}`, estado);\n\n        //obtener modelos disponibles\n        const modelos = modelosPorMarca[marcaElegida];\n\n        if (!modelos || !Array.isArray(modelos)) {\n            node.error(`pedir modelo: no hay modelos para la marca \"${marcaElegida}\"`, msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: `‚ö†Ô∏è No hay modelos cargados para *${marcaElegida}*.`\n            };\n            return msg;\n        }\n\n        //teclado con los primeros modelos\n        const primeras = modelos.slice(0, 8);\n\n        const keyboard = [\n            primeras.slice(0, 4).map(m => m.toUpperCase()),\n            primeras.slice(4, 8).map(m => m.toUpperCase())\n        ];\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: `Perfecto ‚úÖ\\nElegiste *${marcaElegida.toUpperCase()}*.\\n\\nAhora decime el *modelo* del veh√≠culo:`,\n            options: {\n                parse_mode: \"Markdown\",\n                reply_markup: {\n                    keyboard: keyboard,\n                    one_time_keyboard: true,\n                    resize_keyboard: true\n                }\n            }\n        };\n\n        return msg;\n    }\n\n    return null;\n\n} catch (err) {\n\n    //manejo de errores inesperados del sistema\n    node.error(\"pedir modelo: error inesperado ‚Üí \" + err.message, msg);\n\n    msg.payload = {\n        chatId: msg.chatId,\n        type: \"message\",\n        content: \"‚ö†Ô∏è Se produjo un error inesperado. Escrib√≠ /start para reiniciar.\"\n    };\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 620,
        "wires": [
            [
                "c8423aeb93ef2a9a"
            ]
        ]
    },
    {
        "id": "d149d98720ea052c",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "pedir cristal",
        "func": "try {\n\n    //validaci√≥n del payload\n    if (!msg.payload) {\n        node.error(\"pedir cristal: msg.payload est√° indefinido\", msg);\n        return null;\n    }\n\n    const chatId = msg.chatId;\n    if (!chatId) {\n        node.error(\"pedir cristal: falta msg.chatId\", msg);\n        return null;\n    }\n\n    const text = (msg.payload || \"\").toString().trim().toUpperCase();\n\n    //recuperar estado del usuario\n    let estado = flow.get(`estado_${chatId}`);\n    if (!estado || !estado.paso) {\n        node.error(`pedir cristal: estado inv√°lido o ausente para chatId=${chatId}`, msg);\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: \"‚ö†Ô∏è Tu sesi√≥n parece estar incompleta. Escrib√≠ /start para comenzar de nuevo.\"\n        };\n        return msg;\n    }\n\n\n    //solo si el paso es modelo\n    if (estado.paso === \"modelo\") {\n\n        const marca = estado.marca;\n        if (!marca) {\n            node.error(`pedir cristal: estado.marca no definido para chatId=${chatId}`, msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ö†Ô∏è No encontr√© la marca seleccionada. Escrib√≠ /start para reiniciar.\"\n            };\n            return msg;\n        }\n\n        //obtener modelos por marca\n        const modelosPorMarca = global.get(\"catalogo.modelos\");\n        if (!modelosPorMarca || typeof modelosPorMarca !== \"object\") {\n            node.error(\"pedir cristal: global.catalogo.modelos est√° ausente o mal formado\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå Error interno al cargar modelos. Prob√° nuevamente m√°s tarde.\"\n            };\n            return msg;\n        }\n\n        const modelos = modelosPorMarca[marca] || [];\n\n        //buscar modelo elegido\n        const modeloElegido = modelos.find(m => m === text || m.startsWith(text));\n        if (!modeloElegido) {\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: `‚ùå No reconozco ese modelo para *${marca.toUpperCase()}*.\\nProb√° escribirlo de nuevo o envi√° /start para comenzar otra vez.`,\n                options: { parse_mode: \"Markdown\" }\n            };\n            return msg;\n        }\n\n        //actualizar estado\n        estado.modelo = modeloElegido;\n        estado.paso = \"cristal\";\n        flow.set(`estado_${chatId}`, estado);\n\n\n        //obtener cat√°logo\n        const catalog = global.get(\"catalogo.productos\");\n        if (!catalog || !Array.isArray(catalog)) {\n            node.error(\"pedir cristal: global.catalogo.productos ausente o no es un array\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå No se pudo cargar el cat√°logo. Intent√° m√°s tarde.\"\n            };\n            return msg;\n        }\n\n        //normalizador seguro\n        const normalize = s => (s ?? \"\")\n            .toString()\n            .toUpperCase()\n            .normalize(\"NFD\")\n            .replace(/[\\u0300-\\u036f]/g, \"\")\n            .replace(/\\s+/g, \" \")\n            .trim();\n\n        //extraer tipos de cristal disponibles\n        const cristales = [...new Set(\n            catalog\n                .filter(x =>\n                    normalize(x.marca) === normalize(marca) &&\n                    normalize(x.modelo) === normalize(modeloElegido)\n                )\n                .map(x => normalize(x.cristal))\n        )];\n\n        if (!cristales.length) {\n            node.error(`pedir cristal: no se encontraron cristales para ${marca} ${modeloElegido}`, msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: `‚ö†Ô∏è No encontr√© cristales cargados para *${marca} ${modeloElegido}*.`,\n                options: { parse_mode: \"Markdown\" }\n            };\n            return msg;\n        }\n\n\n        //construir teclado\n        const primeros = cristales.slice(0, 6);\n        const keyboard = [\n            primeros.slice(0, 3).map(c => c.toUpperCase()),\n            primeros.slice(3, 6).map(c => c.toUpperCase())\n        ];\n\n        //mensaje siguiente\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: `Perfecto ‚úÖ\\nElegiste *${marca.toUpperCase()} ${modeloElegido.toUpperCase()}*.\\n\\nAhora decime qu√© *cristal* busc√°s`,\n            options: {\n                parse_mode: \"Markdown\",\n                reply_markup: {\n                    keyboard: keyboard,\n                    one_time_keyboard: true,\n                    resize_keyboard: true\n                }\n            }\n        };\n\n        return msg;\n    }\n\n    return null;\n\n} catch (err) {\n\n    //errores inesperados\n    node.error(\"pedir cristal: error inesperado ‚Üí \" + err.message, msg);\n\n    msg.payload = {\n        chatId: msg.chatId,\n        type: \"message\",\n        content: \"‚ö†Ô∏è Ocurri√≥ un error inesperado. Escrib√≠ /start para reiniciar.\"\n    };\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 680,
        "wires": [
            [
                "c8423aeb93ef2a9a"
            ]
        ]
    },
    {
        "id": "25f95448ecd1a39c",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "buscar precios",
        "func": "try {\n\n    //validaci√≥n del payload\n    if (!msg.payload) {\n        node.error(\"buscar precios: msg.payload est√° indefinido\", msg);\n        return null;\n    }\n\n    const chatId = msg.chatId;\n    if (!chatId) {\n        node.error(\"buscar precios: falta msg.chatId\", msg);\n        return null;\n    }\n\n    const text = (msg.payload || \"\").toString().trim().toUpperCase();\n\n    //recuperar estado del usuario\n    let estado = flow.get(`estado_${chatId}`);\n    if (!estado || !estado.paso) {\n        node.error(`buscar precios: estado inv√°lido o ausente para chatId=${chatId}`, msg);\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: \"‚ö†Ô∏è Tu sesi√≥n no est√° completa. Escrib√≠ /start para reiniciar.\"\n        };\n        return msg;\n    }\n\n\n    //solo si el paso es cristal\n    if (estado.paso === \"cristal\") {\n\n        const marca = estado.marca;\n        const modelo = estado.modelo;\n\n        //validaciones del estado\n        if (!marca) {\n            node.error(`buscar precios: estado.marca no definido para chatId=${chatId}`, msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ö†Ô∏è No encontr√© la marca seleccionada. Us√° /start para comenzar de nuevo.\"\n            };\n            return msg;\n        }\n\n        if (!modelo) {\n            node.error(`buscar precios: estado.modelo no definido para chatId=${chatId}`, msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ö†Ô∏è No encontr√© el modelo seleccionado. Us√° /start para comenzar de nuevo.\"\n            };\n            return msg;\n        }\n\n\n        //normalizador\n        const normalize = s => (s ?? \"\")\n            .toString()\n            .toUpperCase()\n            .normalize(\"NFD\")\n            .replace(/[\\u0300-\\u036f]/g, \"\")\n            .replace(/\\s+/g, \" \")\n            .trim();\n\n\n        //obtener cat√°logo\n        const catalog = global.get(\"catalogo.productos\");\n        if (!catalog || !Array.isArray(catalog)) {\n            node.error(\"buscar precios: global.catalogo.productos ausente o no es array\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå No pude acceder al cat√°logo. Prob√° nuevamente m√°s tarde.\"\n            };\n            return msg;\n        }\n\n\n        //buscar coincidencias\n        const cristalIngresado = text;\n\n        const resultados = catalog.filter(item => {\n            //validaci√≥n defensiva del item\n            if (!item || typeof item !== \"object\") {\n                node.error(`buscar precios: item inv√°lido en cat√°logo ‚Üí ${JSON.stringify(item)}`, msg);\n                return false;\n            }\n\n            return (\n                normalize(item.marca) === normalize(marca) &&\n                normalize(item.modelo) === normalize(modelo) &&\n                normalize(item.cristal).startsWith(cristalIngresado)\n            );\n        });\n\n        if (!resultados.length) {\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: `‚ùå No encontr√© precios para *${marca.toUpperCase()} ${modelo.toUpperCase()}* (${cristalIngresado}).\\nProb√° otra pieza o envi√° /start para comenzar de nuevo.`,\n                options: { parse_mode: \"Markdown\" }\n            };\n            return msg;\n        }\n\n        const fmt = v => {\n            if (v === undefined || v === null || v === \"\") return \"-\";\n\n            let s = v.toString().trim();\n\n            if (!s.startsWith(\"$\")) s = \"$\" + s;\n\n            return s;\n        };\n\n\n        //construcci√≥n de respuesta\n        const respuesta = resultados.slice(0, 5).map((r, i) => {\n\n            const descripcion = r.descripci√≥n ?? r.cristal ?? \"(Sin descripci√≥n)\";\n            const codigo = r.c√≥digo ?? \"-\";\n            const color = r.color ?? \"-\";\n            const precio = fmt(\n                r[\"total s/iva\"] ??\n                r[\"precio s/iva\"] ??\n                r[\"precio\"]\n            );\n\n            return `#${i + 1} ‚Äì ${descripcion}\nC√≥digo: ${codigo}\nColor: ${color}\nüíµ Precio: ${precio}`;\n\n        }).join(\"\\n\\n\");\n\n\n        //enviar mensaje\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: `üîç *Resultados para ${marca.toUpperCase()} ${modelo.toUpperCase()} (${cristalIngresado.toUpperCase()})*\\n\\n${respuesta}\\n\\nUs√° /start para hacer otra consulta.`,\n            options: { parse_mode: \"Markdown\" }\n        };\n\n\n        //reiniciar estado para nueva consulta\n        flow.set(`estado_${chatId}`, { paso: null });\n\n        return msg;\n    }\n\n    return null;\n\n\n} catch (err) {\n\n    //errores inesperados\n    node.error(\"buscar precios: error inesperado ‚Üí \" + err.message, msg);\n\n    msg.payload = {\n        chatId: msg.chatId,\n        type: \"message\",\n        content: \"‚ö†Ô∏è Ocurri√≥ un error inesperado al buscar precios. Escrib√≠ /start para reiniciar.\"\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 740,
        "wires": [
            [
                "c8423aeb93ef2a9a"
            ]
        ]
    },
    {
        "id": "9ce3d5bb0df5ab47",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "router inputs",
        "func": "try {\n\n    //validaci√≥n m√≠nima del payload\n    if (!msg.payload) {\n        node.error(\"router inputs: msg.payload est√° indefinido\", msg);\n        return [null, null];\n    }\n\n    const chatId = msg.payload.chatId;\n\n    //chatId obligatorio\n    if (!chatId) {\n        node.error(\"router inputs: falta msg.payload.chatId\", msg);\n        return [null, null];\n    }\n\n    //normalizar texto, pero validando antes\n    const content = msg.payload.content;\n    if (content === undefined || content === null) {\n        node.error(`router inputs: msg.payload.content no existe (chatId=${chatId})`, msg);\n        return [null, null];\n    }\n\n    const text = content.toString().trim().toLowerCase();\n\n    //recuperar estado del usuario\n    let estado = flow.get(`estado_${chatId}`) || { paso: null };\n\n    //variables originales para subflujos posteriores\n    msg.chatId = chatId;\n    msg.text_original = content;\n\n    //detectar comandos\n    if (\n        text.startsWith(\"/start\") ||\n        text.startsWith(\"/ayuda\") ||\n        text.startsWith(\"/cancel\")\n    ) {\n        msg.meta = { tipo: \"comando\", comando: text.replace(\"/\", \"\") };\n        return [msg, null]; // salida comandos\n    }\n\n    //mensajes normales\n    msg.meta = { tipo: \"mensaje\", paso: estado.paso };\n    return [null, msg]; // salida mensajes normales\n\n} catch (err) {\n\n    //errores inesperados\n    node.error(\"router inputs: error inesperado ‚Üí \" + err.message, msg);\n\n    return [null, null];\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 560,
        "wires": [
            [
                "82c275f0d94cc151"
            ],
            [
                "b13d790a754ae6fc"
            ]
        ]
    },
    {
        "id": "88f1d6b3578b6dde",
        "type": "switch",
        "z": "6d76aee88f994823",
        "name": "orquestador",
        "property": "meta.paso",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "marca",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "modelo",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "cristal",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 850,
        "y": 680,
        "wires": [
            [
                "d16fdcf0d9f4353c"
            ],
            [
                "d149d98720ea052c"
            ],
            [
                "25f95448ecd1a39c"
            ]
        ]
    },
    {
        "id": "82c275f0d94cc151",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "gestor comandos",
        "func": "try {\n\n    //validaciones b√°sicas\n    if (!msg.payload) {\n        node.error(\"gestor comandos: msg.payload est√° indefinido\", msg);\n        return null;\n    }\n\n    const chatId = msg.payload.chatId;\n\n    if (!chatId) {\n        node.error(\"gestor comandos: falta msg.payload.chatId\", msg);\n        return null;\n    }\n\n    if (!msg.meta || !msg.meta.comando) {\n        node.error(`gestor comandos: comando no encontrado en msg.meta (chatId=${chatId})`, msg);\n        return null;\n    }\n\n    const cmd = msg.meta.comando;\n\n    if (cmd === \"start\") {\n\n        //reiniciar estado del usuario\n        flow.set(`estado_${chatId}`, { paso: \"marca\" });\n\n        //obtener marcas del cat√°logo\n        const marcas = global.get(\"catalogo.marcas\");\n\n        if (!marcas || !Array.isArray(marcas)) {\n            node.error(\"gestor comandos: global.catalogo.marcas no existe o no es un array\", msg);\n\n            msg.payload = {\n                chatId,\n                type: \"message\",\n                content: \"‚ùå Error interno: no se pudo cargar la lista de marcas. Prob√° m√°s tarde.\"\n            };\n\n            return msg;\n        }\n\n        //funci√≥n para capitalizar\n        const capitalize = s =>\n            (!s ? \"\" : s.charAt(0).toUpperCase() + s.slice(1).toLowerCase());\n\n        const primeras = marcas.slice(5, 15);\n\n        const keyboard = [\n            primeras.slice(0, 4).map(m => capitalize(m)),\n            primeras.slice(4, 8).map(m => capitalize(m))\n        ];\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: \"üëã ¬°Hola! Soy tu asistente de precios de Pilkington.\\n\\nIngres√° la *marca* del veh√≠culo:\",\n            options: {\n                parse_mode: \"Markdown\",\n                reply_markup: {\n                    keyboard: keyboard,\n                    one_time_keyboard: true,\n                    resize_keyboard: true\n                }\n            }\n        };\n\n        return msg;\n    }\n\n    if (cmd === \"ayuda\") {\n\n        const textoAyuda =\n            `*ü§ñ ¬øC√≥mo usar este Asistente?*\n\nEste bot te ayuda a encontrar precios de cristales para veh√≠culos. El flujo es simple:\n\n1Ô∏è‚É£ Primero, te pedir√© la *Marca* (ej: Ford).  \n2Ô∏è‚É£ Luego, te pedir√© el *Modelo* (ej: Fiesta).  \n3Ô∏è‚É£ Finalmente, te pedir√© el *Cristal* (ej: Parabrisas).  \n\nCon esa informaci√≥n, buscar√© el precio en nuestro cat√°logo.\n\n*Comandos Disponibles:*  \n‚Ä¢ /start - Inicia una nueva consulta o reinicia la actual.  \n‚Ä¢ /ayuda - Muestra este mensaje.`;\n\n        msg.payload = {\n            chatId,\n            type: \"message\",\n            content: textoAyuda,\n            options: {\n                parse_mode: \"Markdown\"\n            }\n        };\n\n        return msg;\n    }\n\n    node.error(`gestor comandos: comando desconocido \"${cmd}\"`, msg);\n\n    msg.payload = {\n        chatId,\n        type: \"message\",\n        content: \"‚ùì Comando no reconocido. Us√° /start o /ayuda.\"\n    };\n\n    return msg;\n\n\n} catch (err) {\n\n    //error inesperado\n    node.error(`gestor comandos: error inesperado ‚Üí ${err.message}`, msg);\n\n    msg.payload = {\n        chatId: msg.payload?.chatId,\n        type: \"message\",\n        content: \"‚ö†Ô∏è Ocurri√≥ un error interno procesando tu comando.\"\n    };\n\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 560,
        "wires": [
            [
                "c8423aeb93ef2a9a"
            ]
        ]
    },
    {
        "id": "b13d790a754ae6fc",
        "type": "subflow:subflow_normalizar",
        "z": "6d76aee88f994823",
        "name": "",
        "x": 600,
        "y": 680,
        "wires": [
            [
                "88f1d6b3578b6dde"
            ]
        ]
    },
    {
        "id": "7df1eb0dedc00bc5",
        "type": "catch",
        "z": "6d76aee88f994823",
        "name": "Capturador de errores",
        "scope": null,
        "uncaught": false,
        "x": 860,
        "y": 840,
        "wires": [
            [
                "8246547d45e16c3e"
            ]
        ]
    },
    {
        "id": "8246547d45e16c3e",
        "type": "function",
        "z": "6d76aee88f994823",
        "name": "Formateador de errores",
        "func": "// El nodo Catch entrega el error en msg.error o msg.payload\nconst err = msg.error || msg.payload;\n\n//obtener info del error\nconst errorMessage = err?.message || \"Error desconocido\";\nconst source = err?.source || {};\nconst nodoNombre = source.name || \"Nodo sin nombre\";\nconst nodoId = source.id || \"sin-id\";\nconst nodoTipo = source.type || \"desconocido\";\n\n// Obtener chatId si estaba en el msg original, si no agarra el fijo\nconst chatId = msg.chatId || err?.source?.chatId || 5810645399;\n\n//mensaje para Telegram\nmsg.payload = {\n    chatId,\n    type: \"message\",\n    content:\n        `‚ö†Ô∏è *ERROR DETECTADO*\n\n*Mensaje:* ${errorMessage}\n*Nodo:* ${nodoNombre}\n*Tipo:* ${nodoTipo}\n*ID:* ${nodoId}\n\n_Revis√° los logs y correg√≠ el flujo._`,\n    options: { parse_mode: \"Markdown\" }\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 840,
        "wires": [
            [
                "c8423aeb93ef2a9a"
            ]
        ]
    },
    {
        "id": "1ed20e756ff9133c",
        "type": "debug",
        "z": "6d76aee88f994823",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 400,
        "wires": []
    }
]